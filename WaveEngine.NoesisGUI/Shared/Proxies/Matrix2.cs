//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Matrix2 {

  private Point _r0;
  private Point _r1;

  public Point this[uint i] {
    get {
      switch (i) {
        case 0: return this._r0;
        case 1: return this._r1;
        default: throw new IndexOutOfRangeException();
      }
    }
    set {
      switch (i) {
        case 0: this._r0 = value; break;
        case 1: this._r1 = value; break;
        default: throw new IndexOutOfRangeException();
      }
    }
  }

  public static Matrix2 Identity {
    get { return new Matrix2(1.0f, 0.0f, 0.0f, 1.0f); }
  }

  public Matrix2(float m00, float m01, float m10, float m11) : this(
    new Point(m00, m01), new Point(m10, m11))
  {
  }

  public Matrix2(Point v0, Point v1) {
    this._r0 = v0;
    this._r1 = v1;
  }

  public static Matrix2 operator*(Matrix2 m, float f) {
    return new Matrix2(m[0] * f, m[1] * f);
  }

  public static Matrix2 operator*(float f, Matrix2 m) {
    return m * f;
  }

  public static Matrix2 operator/(Matrix2 m, float f) {
    if (f == 0.0f) { throw new DivideByZeroException(); }
    return new Matrix2(m[0] / f, m[1] / f);
  }

  public static Point operator*(Point v, Matrix2 m) {
    return new Point(
      v[0] * m[0][0] + v[1] * m[1][0],
      v[0] * m[0][1] + v[1] * m[1][1]);
  }

  public static Matrix2 operator*(Matrix2 m0, Matrix2 m1) {
    return new Matrix2(
      new Point(
        m0[0][0] * m1[0][0] + m0[0][1] * m1[1][0],
        m0[0][0] * m1[0][1] + m0[0][1] * m1[1][1]),
      new Point(
        m0[1][0] * m1[0][0] + m0[1][1] * m1[1][0],
        m0[1][0] * m1[0][1] + m0[1][1] * m1[1][1])
    );
  }

  public static bool operator==(Matrix2 m0, Matrix2 m1) {
    return m0[0] == m1[0] && m0[1] == m1[1];
  }

  public static bool operator!=(Matrix2 m0, Matrix2 m1) {
    return !(m0 == m1);
  }

  public override bool Equals(System.Object obj) {
    return obj is Matrix2 && this == (Matrix2)obj;
  }

  public bool Equals(Matrix2 m) {
    return this == m;
  }

  public override int GetHashCode() {
    return this[0].GetHashCode() ^ this[1].GetHashCode();
  }

  public static Matrix2 Scale(float scaleX, float scaleY) {
    return new Matrix2(scaleX, 0.0f, 0.0f, scaleY);
  }

  public static Matrix2 Rot(float radians) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix2(cs, sn, -sn, cs);
  }

  public static Matrix2 ShearXY(float shear) {
    return new Matrix2(1.0f, 0.0f, shear, 1.0f);
  }

  public static Matrix2 ShearYX(float shear) {
    return new Matrix2(1.0f, shear, 0.0f, 1.0f);
  }

  public static Matrix2 Transpose(Matrix2 m) {
    return new Matrix2(m[0][0], m[1][0], m[0][1], m[1][1]);
  }

  public static float Determinant(Matrix2 m) {
    return m[0][0] * m[1][1] - m[0][1] * m[1][0];
  }

  public static Matrix2 Inverse(Matrix2 m) {
    return Inverse(m, Determinant(m));
  }

  public static Matrix2 Inverse(Matrix2 m, float determinant) {
    return new Matrix2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / determinant;
  }

  public static Matrix2 PreScale(float scaleX, float scaleY, Matrix2 m) {
    return new Matrix2(m[0][0] * scaleX, m[0][1] * scaleX, m[1][0] * scaleY, m[1][1] * scaleY);
  }

  public static Matrix2 PreRot(float radians, Matrix2 m) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix2(
      m[0][0] * cs + m[1][0] * sn, m[0][1] * cs + m[1][1] * sn,
      m[1][0] * cs - m[0][0] * sn, m[1][1] * cs - m[0][1] * sn);
  }

  public static Matrix2 PostScale(Matrix2 m, float scaleX, float scaleY) {
    return new Matrix2(m[0][0] * scaleX, m[0][1] * scaleY, m[1][0] * scaleX, m[1][1] * scaleY);
  }

  public static Matrix2 PostRot(Matrix2 m, float radians) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix2(
      m[0][0] * cs - m[0][1] * sn,
      m[0][1] * cs + m[0][0] * sn,
      m[1][0] * cs - m[1][1] * sn,
      m[1][1] * cs + m[1][0] * sn);
  }

  private static float Sign(float a) {
    return a == 0.0f ? 0.0f : (a > 0.0f ? 1.0f : -1.0f);
  }

  public static void Decompose(Matrix2 m, out float scaleX, out float scaleY, out float shearXY,
    out float rot) {
    Matrix2 mtx = m;

    scaleX = Point.Length(mtx[0]) * Matrix2.Sign(mtx[0][0]);
    mtx[0] = mtx[0] / scaleX;

    shearXY = Point.Dot(mtx[0], mtx[1]);
    mtx[1] -= mtx[0] * shearXY;

    scaleY = Point.Length(mtx[1]) * Matrix2.Sign(mtx[1][1]);
    mtx[1] = mtx[1] / scaleY;

    shearXY /= scaleY;

    rot = (float)Math.Atan2(-mtx[1][0], mtx[1][1]);
  }

}

}

