//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Rect {

  [MarshalAs(UnmanagedType.R4)]
  private float _x;

  [MarshalAs(UnmanagedType.R4)]
  private float _y;

  [MarshalAs(UnmanagedType.R4)]
  private float _w;

  [MarshalAs(UnmanagedType.R4)]
  private float _h;

  public float X {
    get { return this._x; }
    set { this._x = value; }
  }

  public float Y {
    get { return this._y; }
    set { this._y = value; }
  }

  public float Width {
    get { return this._w; }
    set {
      if (value < 0.0f) {
        throw new ArgumentException("Width cannot be negative");
      }
      this._w = value;
    }
  }

  public float Height {
    get { return this._h; }
    set {
      if (value < 0.0f) {
        throw new ArgumentException("Height cannot be negative");
      }
      this._h = value;
    }
  }

  public Point Location {
    get { return new Point(X, Y); }
    set { X = value.X; Y = value.Y; }
  }

  public Size Size {
    get { return new Size(Width, Height); }
    set { Width = value.Width; Height = value.Height; }
  }

  public float Left {
    get { return X; }
  }

  public float Right {
    get { return X + Width; }
  }
  
  public float Top {
    get { return Y; }
  }

  public float Bottom {
    get { return Y + Height; }
  }

  public Point TopLeft {
    get { return new Point(Left, Top); }
  }

  public Point TopRight {
    get { return new Point(Right, Top); }
  }

  public Point BottomLeft {
    get { return new Point(Left, Bottom); }
  }

  public Point BottomRight {
    get { return new Point(Right, Bottom); }
  }

  public bool IsEmpty {
    get { return Width == 0.0f || Height == 0.0f; }
  }

  public static Rect Empty {
    get { return new Rect(); }
  }

  public static Rect Infinite {
    get {
      return new Rect(
        (float)Double.NegativeInfinity, (float)Double.NegativeInfinity,
        (float)Double.PositiveInfinity, (float)Double.PositiveInfinity);
    }
  }

  public Rect(float x, float y, float width, float height) {
    if (width < 0.0f || height < 0.0f) {
      throw new ArgumentException("Width and Height cannot be negative");
    }
    this._x = x;
    this._y = y;
    this._w = width;
    this._h = height;
  }

  public Rect(Size size) : this(0.0f, 0.0f, size.Width, size.Height)
  {
  }

  public Rect(Point p, Size size) : this(p.X, p.Y, size.Width, size.Height)
  {
  }

  public Rect(Recti rect) : this((float)rect.X, (float)rect.Y, (float)rect.Width, (float)rect.Height)
  {
  }

  public static bool operator==(Rect r0, Rect r1) {
    return r0.X == r1.X && r0.Y == r1.Y && r0.Width == r1.Width && r0.Height == r1.Height;
  }

  public static bool operator!=(Rect r0, Rect r1) {
    return !(r0 == r1);
  }

  public override bool Equals(Object obj) {
    return obj is Rect && this == (Rect)obj;
  }

  public bool Equals(Rect r) {
    return this == r;
  }

  public override int GetHashCode() {
    return ((X.GetHashCode() ^ Y.GetHashCode()) ^ Width.GetHashCode()) ^ Height.GetHashCode();
  }

  public override string ToString() {
    return String.Format("{0},{1},{2},{3}", X, Y, Width, Height);
  }

  public bool Contains(float x, float y) {
    return x >= Left && x <= Right && y >= Top && y <= Bottom;
  }

  public bool Contains(Point point) {
    return Contains(point.X, point.Y);
  }

  public bool Contains(Rect rect) {
    return rect.Left >= Left && rect.Right <= Right && rect.Top >= Top && rect.Bottom <= Bottom;
  }

  public void Inflate(float width, float height) {
    float w2 = width * 2.0f;
    float h2 = height * 2.0f;
    if ((w2 < 0.0f && -w2 >= Width) || (h2 < 0.0f && -h2 >= Height)) {
      this = Empty;
    }
    else {
      X -= width;
      Y -= height;
      Width += w2;
      Height += h2;
    }
  }

  public void Inflate(Size size) {
    Inflate(size.Width, size.Height);
  }

  public Rect Intersect(Rect rect) {
    float x = rect.Left < Left ? (rect.Right > Left ? Left : 0.0f) : (rect.Left < Right ? rect.Left : 0.0f);
    float y = rect.Top < Top ? (rect.Bottom > Top ? Top : 0.0f) : (rect.Top < Bottom ? rect.Top : 0.0f);
    float w = Math.Max(0.0f, (rect.Right > Right ? (rect.Left < Right ? Right : 0.0f) : (rect.Right > Left ? rect.Right : 0.0f)) - x);
    float h = Math.Max(0.0f, (rect.Bottom > Bottom ? (rect.Top < Bottom ? Bottom : 0.0f) : (rect.Bottom > Top ? rect.Bottom : 0.0f)) - y);
    if (w == 0.0f || h == 0.0f) {
      return Rect.Empty;
    }
    else {
      return new Rect(x, y, w, h);
    }
  }

  public bool IntersectsWith(Rect rect) {
    return !Intersect(rect).IsEmpty;
  }

  public void Offset(float x, float y) {
    X += x;
    Y += y;
  }

  public void Offset(Point offset) {
    Offset(offset.X, offset.Y);
  }

  public void Scale(float scaleX, float scaleY) {
    if (scaleX < 0.0f) {
      Width *= -scaleX;
      X = X * scaleX - Width;
    }
    else {
      Width *= scaleX;
      X *= scaleX;
    }
    if (scaleY < 0.0f) {
      Height *= -scaleY;
      Y = Y * scaleY - Height;
    }
    else {
      Height *= scaleY;
      Y *= scaleY;
    }
  }

  public void Expand(Point point) {
    float right = Right;
    float bottom = Bottom;
    X = Math.Min(X, point.X);
    Y = Math.Min(Y, point.Y);
    Width = Math.Max(right, point.X) - X;
    Height = Math.Max(bottom, point.Y) - Y;
  }

  public void Expand(Rect rect) {
    float right = Right;
    float bottom = Bottom;
    X = Math.Min(X, rect.X);
    Y = Math.Min(Y, rect.Y);
    Width = Math.Max(right, rect.Right) - X;
    Height = Math.Max(bottom, rect.Bottom) - Y;
  }

  public void Transform(Transform2 m) {
    if (!Double.IsInfinity(Width) && !Double.IsInfinity(Height)) {
      Point tl = TopLeft * m;
      Point tr = TopRight * m;
      Point bl = BottomLeft * m;
      Point br = BottomRight * m;
      Size = Size.Zero;
      Location = tl;
      Expand(tr);
      Expand(bl);
      Expand(br);
    }
  }

  public void Transform(Matrix4 m) {
    if (!Double.IsInfinity(Width) && !Double.IsInfinity(Height)) {
      Vector4 tl = new Vector4(TopLeft, 0.0f, 1.0f) * m;
      Vector4 tr = new Vector4(TopRight, 0.0f, 1.0f) * m;
      Vector4 bl = new Vector4(BottomLeft, 0.0f, 1.0f) * m;
      Vector4 br = new Vector4(BottomRight, 0.0f, 1.0f) * m;
      Size = Size.Zero;
      Location = tl.XY / tl.W;
      Expand(tr.XY / tr.W);
      Expand(bl.XY / bl.W);
      Expand(br.XY / br.W);
    }
  }

  public static Rect Parse(string str) {
    Rect r;
    if (Rect.TryParse(str, out r)) {
      return r;
    }
    throw new ArgumentException("Cannot create Rect from '" + str + "'");
  }

  public static bool TryParse(string str, out Rect result) {
    bool ret = NoesisGUI_PINVOKE.Rect_TryParse(str != null ? str : string.Empty, out result);
    if (NoesisGUI_PINVOKE.SWIGPendingException.Pending) throw NoesisGUI_PINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}

