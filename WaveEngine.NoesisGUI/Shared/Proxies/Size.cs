//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Size {

  [MarshalAs(UnmanagedType.R4)]
  private float _w;

  [MarshalAs(UnmanagedType.R4)]
  private float _h;

  public float Width {
    get { return this._w; }
    set {
      if (value < 0.0f) {
        throw new ArgumentException("Width cannot be negative");
      }
      this._w = value;
    }
  }

  public float Height {
    get { return this._h; }
    set {
      if (value < 0.0f) {
        throw new ArgumentException("Height cannot be negative");
      }
      this._h = value;
    }
  }

  public static Size Zero {
    get { return new Size(0.0f, 0.0f); }
  }

  public static Size Infinite {
    get { return new Size((float)Double.PositiveInfinity, (float)Double.PositiveInfinity); }
  }

  public Size(float w, float h) {
    this._w = w;
    this._h = h;
  }

  public Size(Sizei size) : this((float)size.Width, (float)size.Height) {
  }

  public Size(Point point) : this(point.X, point.Y) {
  }

  public static Size operator+(Size v0, Size v1) {
    return new Size(v0.Width + v1.Width, v0.Height + v1.Height);
  }

  public static Size operator-(Size v0, Size v1) {
    return new Size(v0.Width - v1.Width, v0.Height - v1.Height);
  }

  public static Size operator*(Size v, float f) {
    return new Size(v.Width * f, v.Height * f);
  }

  public static Size operator*(float f, Size v) {
    return v * f;
  }

  public static Size operator/(Size v, float f) {
    if (f == 0.0f) { throw new DivideByZeroException(); }
    return new Size(v.Width / f, v.Height / f);
  }

  public static bool operator==(Size v0, Size v1) {
    return v0.Width == v1.Width && v0.Height == v1.Height;
  }

  public static bool operator!=(Size v0, Size v1) {
    return !(v0 == v1);
  }

  public override bool Equals(Object obj) {
    return obj is Size && this == (Size)obj;
  }

  public bool Equals(Size v) {
    return this == v;
  }

  public override int GetHashCode() {
    return Width.GetHashCode() ^ Height.GetHashCode();
  }

  public override string ToString() {
    return String.Format("{0},{1}", Width, Height);
  }

  public void Expand(Size size) {
    Width = Math.Max(Width, size.Width);
    Height = Math.Max(Height, size.Height);
  }

  public void Scale(float scaleX, float scaleY) {
    Width = Width * scaleX;
    Height = Height * scaleY;
  }

  public static Size Parse(string str) {
    Size size;
    if (Size.TryParse(str, out size)) {
      return size;
    }
    throw new ArgumentException("Cannot create Size from '" + str + "'");
  }

  public static bool TryParse(string str, out Size result) {
    bool ret = NoesisGUI_PINVOKE.Size_TryParse(str != null ? str : string.Empty, out result);
    if (NoesisGUI_PINVOKE.SWIGPendingException.Pending) throw NoesisGUI_PINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}

