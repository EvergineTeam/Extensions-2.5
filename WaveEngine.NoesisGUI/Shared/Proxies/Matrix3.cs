//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Matrix3 {

  private Vector3 _r0;
  private Vector3 _r1;
  private Vector3 _r2;

  public Vector3 this[uint i] {
    get {
      switch (i) {
        case 0: return this._r0;
        case 1: return this._r1;
        case 2: return this._r2;
        default: throw new IndexOutOfRangeException();
      }
    }
    set {
      switch (i) {
        case 0: this._r0 = value; break;
        case 1: this._r1 = value; break;
        case 2: this._r2 = value; break;
        default: throw new IndexOutOfRangeException();
      }
    }
  }

  public static Matrix3 Identity {
    get { return new Matrix3(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f); }
  }

  public Matrix3(
    float m00, float m01, float m02,
    float m10, float m11, float m12,
    float m20, float m21, float m22) : this(
    new Vector3(m00, m01, m02),
    new Vector3(m10, m11, m12),
    new Vector3(m20, m21, m22))
  {
  }

  public Matrix3(Vector3 v0, Vector3 v1, Vector3 v2) {
    this._r0 = v0;
    this._r1 = v1;
    this._r2 = v2;
  }

  public Matrix3(Transform2 m) : this(
    new Vector3(m[0], 0.0f), new Vector3(m[1], 0.0f), new Vector3(m[2], 1.0f))
  {
  }

  public static Matrix3 operator*(Matrix3 m, float f) {
    return new Matrix3(m[0] * f, m[1] * f, m[2] * f);
  }

  public static Matrix3 operator*(float f, Matrix3 m) {
    return m * f;
  }

  public static Matrix3 operator/(Matrix3 m, float f) {
    if (f == 0.0f) { throw new DivideByZeroException(); }
    return new Matrix3(m[0] / f, m[1] / f, m[2] / f);
  }

  public static Vector3 operator*(Vector3 v, Matrix3 m) {
    return new Vector3(
      v[0] * m[0][0] + v[1] * m[1][0] + v[2] * m[2][0],
      v[0] * m[0][1] + v[1] * m[1][1] + v[2] * m[2][1],
      v[0] * m[0][2] + v[1] * m[1][2] + v[2] * m[2][2]);
  }

  public static Matrix3 operator*(Matrix3 m0, Matrix3 m1) {
    return new Matrix3(
      new Vector3(
        m0[0][0] * m1[0][0] + m0[0][1] * m1[1][0] + m0[0][2] * m1[2][0],
        m0[0][0] * m1[0][1] + m0[0][1] * m1[1][1] + m0[0][2] * m1[2][1],
        m0[0][0] * m1[0][2] + m0[0][1] * m1[1][2] + m0[0][2] * m1[2][2]),
      new Vector3(
        m0[1][0] * m1[0][0] + m0[1][1] * m1[1][0] + m0[1][2] * m1[2][0],
        m0[1][0] * m1[0][1] + m0[1][1] * m1[1][1] + m0[1][2] * m1[2][1],
        m0[1][0] * m1[0][2] + m0[1][1] * m1[1][2] + m0[1][2] * m1[2][2]),
      new Vector3(
        m0[2][0] * m1[0][0] + m0[2][1] * m1[1][0] + m0[2][2] * m1[2][0],
        m0[2][0] * m1[0][1] + m0[2][1] * m1[1][1] + m0[2][2] * m1[2][1],
        m0[2][0] * m1[0][2] + m0[2][1] * m1[1][2] + m0[2][2] * m1[2][2])
    );
  }

  public static Matrix3 operator*(Transform2 m0, Matrix3 m1) {
    return new Matrix3(
      new Vector3(
        m0[0][0] * m1[0][0] + m0[0][1] * m1[1][0],
        m0[0][0] * m1[0][1] + m0[0][1] * m1[1][1],
        m0[0][0] * m1[0][2] + m0[0][1] * m1[1][2]),
      new Vector3(
        m0[1][0] * m1[0][0] + m0[1][1] * m1[1][0],
        m0[1][0] * m1[0][1] + m0[1][1] * m1[1][1],
        m0[1][0] * m1[0][2] + m0[1][1] * m1[1][2]),
      new Vector3(
        m0[2][0] * m1[0][0] + m0[2][1] * m1[1][0] + m1[2][0],
        m0[2][0] * m1[0][1] + m0[2][1] * m1[1][1] + m1[2][1],
        m0[2][0] * m1[0][2] + m0[2][1] * m1[1][2] + m1[2][2])
    );
  }

  public static Matrix3 operator*(Matrix3 m0, Transform2 m1) {
    return new Matrix3(
      new Vector3(
        m0[0][0] * m1[0][0] + m0[0][1] * m1[1][0] + m0[0][2] * m1[2][0],
        m0[0][0] * m1[0][1] + m0[0][1] * m1[1][1] + m0[0][2] * m1[2][1],
        m0[0][2]),
      new Vector3(
        m0[1][0] * m1[0][0] + m0[1][1] * m1[1][0] + m0[1][2] * m1[2][0],
        m0[1][0] * m1[0][1] + m0[1][1] * m1[1][1] + m0[1][2] * m1[2][1],
        m0[1][2]),
      new Vector3(
        m0[2][0] * m1[0][0] + m0[2][1] * m1[1][0] + m0[2][2] * m1[2][0],
        m0[2][0] * m1[0][1] + m0[2][1] * m1[1][1] + m0[2][2] * m1[2][1],
        m0[2][2])
    );
  }

  public static bool operator==(Matrix3 m0, Matrix3 m1) {
    return m0[0] == m1[0] && m0[1] == m1[1] && m0[2] == m1[2];
  }

  public static bool operator!=(Matrix3 m0, Matrix3 m1) {
    return !(m0 == m1);
  }

  public override bool Equals(Object obj) {
    return obj is Matrix3 && this == (Matrix3)obj;
  }

  public bool Equals(Matrix3 m) {
    return this == m;
  }

  public override int GetHashCode() {
    return (this[0].GetHashCode() ^ this[1].GetHashCode()) ^ this[2].GetHashCode();
  }

  public static Matrix3 Scale(float scaleX, float scaleY, float scaleZ) {
    return new Matrix3(scaleX, 0.0f, 0.0f, 0.0f, scaleY, 0.0f, 0.0f, 0.0f, scaleZ);
  }

  public static Matrix3 RotX(float radians) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix3(1.0f, 0.0f, 0.0f, 0.0f, cs, sn, 0.0f, -sn, cs);
  }

  public static Matrix3 RotY(float radians) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix3(cs, 0.0f, sn, 0.0f, 1.0f, 0.0f, -sn, 0.0f, cs);
  }

  public static Matrix3 RotZ(float radians) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix3(cs, sn, 0.0f, -sn, cs, 0.0f, 0.0f, 0.0f, 1.0f);
  }

  public static Matrix3 EulerZXY(float x, float y, float z) {
    return Matrix3.RotZ(z) * Matrix3.RotX(x) * Matrix3.RotY(y);
  }

  public static Matrix3 Transpose(Matrix3 m) {
    return new Matrix3(m[0][0], m[1][0], m[2][0], m[0][1], m[1][1], m[2][1], m[0][2], m[1][2], m[2][2]);
  }

  public static bool IsAffine(Matrix3 m) {
    Vector3 v0 = new Vector3(m[0][2], m[1][2], m[2][2]);
    Vector3 v1 = new Vector3(0.0f, 0.0f, 1.0f);
    return Math.Abs(Vector3.LengthSquared(v0 - v1)) < 0.00001f;
  }

  public static float Determinant(Matrix3 m) {
    return
      (m[0][0] * m[1][1] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1]) -
      (m[0][0] * m[1][2] * m[2][1] + m[0][1] * m[1][0] * m[2][2] + m[0][2] * m[1][1] * m[2][0]);
  }

  public static Matrix3 Inverse(Matrix3 m) {
    return Inverse(m, Determinant(m));
  }

  public static Matrix3 Inverse(Matrix3 m, float determinant) {
    return new Matrix3(
      m[1][1] * m[2][2] - m[1][2] * m[2][1],
      m[0][2] * m[2][1] - m[0][1] * m[2][2],
      m[0][1] * m[1][2] - m[0][2] * m[1][1],

      m[1][2] * m[2][0] - m[1][0] * m[2][2],
      m[0][0] * m[2][2] - m[0][2] * m[2][0],
      m[0][2] * m[1][0] - m[0][0] * m[1][2],

      m[1][0] * m[2][1] - m[1][1] * m[2][0],
      m[0][1] * m[2][0] - m[0][0] * m[2][1],
      m[0][0] * m[1][1] - m[0][1] * m[1][0]) / determinant; 
  }

  public static Matrix3 Orthonormalize(Matrix3 m) {
    Vector3 v0 = Vector3.Normalize(m[0]);
    Vector3 v1 = Vector3.Normalize(m[1] - Vector3.Dot(m[1], v0) * v0);
    Vector3 v2 = Vector3.Normalize(m[2] - Vector3.Dot(m[2], v0) * v0 - Vector3.Dot(m[2], v1) * v1);
    return new Matrix3(v0, v1, v2);
  }

  public static Matrix3 PreScale(float scaleX, float scaleY, float scaleZ, Matrix3 m) {
    return new Matrix3(
      m[0][0] * scaleX, m[0][1] * scaleX, m[0][2] * scaleX,
      m[1][0] * scaleY, m[1][1] * scaleY, m[1][2] * scaleY,
      m[2][0] * scaleZ, m[2][1] * scaleZ, m[2][2] * scaleZ);
  }

  public static Matrix3 PreRotX(float radians, Matrix3 m) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix3(
                          m[0][0],                     m[0][1],                     m[0][2],
      m[1][0] * cs + m[2][0] * sn, m[1][1] * cs + m[2][1] * sn, m[1][2] * cs + m[2][2] * sn,
      m[2][0] * cs - m[1][0] * sn, m[2][1] * cs - m[1][1] * sn, m[2][2] * cs - m[1][2] * sn);
  }

  public static Matrix3 PreRotY(float radians, Matrix3 m) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix3(
      m[0][0] * cs + m[2][0] * sn, m[0][1] * cs + m[2][1] * sn, m[0][2] * cs + m[2][2] * sn,
                          m[1][0],                     m[1][1],                     m[1][2],
      m[2][0] * cs - m[0][0] * sn, m[2][1] * cs - m[0][1] * sn, m[2][2] * cs - m[0][2] * sn);
  }

  public static Matrix3 PreRotZ(float radians, Matrix3 m) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix3(
      m[0][0] * cs + m[1][0] * sn, m[0][1] * cs + m[1][1] * sn, m[0][2] * cs + m[1][2] * sn,
      m[1][0] * cs - m[0][0] * sn, m[1][1] * cs - m[0][1] * sn, m[1][2] * cs - m[0][2] * sn,
                          m[2][0],                     m[2][1],                     m[2][2]);
  }

  public static Matrix3 PostScale(Matrix3 m, float scaleX, float scaleY, float scaleZ) {
    return new Matrix3(
      m[0][0] * scaleX, m[0][1] * scaleY, m[0][2] * scaleZ,
      m[1][0] * scaleX, m[1][1] * scaleY, m[1][2] * scaleZ,
      m[2][0] * scaleX, m[2][1] * scaleY, m[2][2] * scaleZ);
  }

  public static Matrix3 PostRotX(Matrix3 m, float radians) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix3(
      m[0][0], m[0][1] * cs - m[0][2] * sn, m[0][2] * cs + m[0][1] * sn,
      m[1][0], m[1][1] * cs - m[1][2] * sn, m[1][2] * cs + m[1][1] * sn,
      m[2][0], m[2][1] * cs - m[2][2] * sn, m[2][2] * cs + m[2][1] * sn);
  }

  public static Matrix3 PostRotY(Matrix3 m, float radians) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix3(
      m[0][0] * cs - m[0][2] * sn, m[0][1], m[0][2] * cs + m[0][0] * sn,
      m[1][0] * cs - m[1][2] * sn, m[1][1], m[1][2] * cs + m[1][0] * sn,
      m[2][0] * cs - m[2][2] * sn, m[2][1], m[2][2] * cs + m[2][0] * sn);
  }

  public static Matrix3 PostRotZ(Matrix3 m, float radians) {
    float cs = (float)Math.Cos(radians);
    float sn = (float)Math.Sin(radians);
    return new Matrix3(
      m[0][0] * cs - m[0][1] * sn, m[0][1] * cs + m[0][0] * sn, m[0][2],
      m[1][0] * cs - m[1][1] * sn, m[1][1] * cs + m[1][0] * sn, m[1][2],
      m[2][0] * cs - m[2][1] * sn, m[2][1] * cs + m[2][0] * sn, m[2][2]);
  }

  public static void Decompose(Matrix3 m,
    out float scaleX, out float scaleY, out float scaleZ,
    out float shearXY, out float shearXZ, out float shearZY,
    out float rotateX, out float rotateY, out float rotateZ) {
    Matrix3 mtx = m;

    scaleX = Vector3.Length(mtx[0]);
    mtx[0] = Vector3.Normalize(mtx[0]);

    shearXY = Vector3.Dot(mtx[0], mtx[1]);
    mtx[1] -= mtx[0] * shearXY;

    scaleY = Vector3.Length(mtx[1]);
    mtx[1] = Vector3.Normalize(mtx[1]);

    shearXY /= scaleY;

    shearXZ = Vector3.Dot(mtx[0], mtx[2]);
    mtx[2] -= mtx[0] * shearXZ;

    shearZY = Vector3.Dot(mtx[1], mtx[2]);
    mtx[2] -= mtx[1] * shearZY;

    scaleZ = Vector3.Length(mtx[2]);
    mtx[2] = Vector3.Normalize(mtx[2]);

    shearXZ /= scaleZ;
    shearZY /= scaleZ;

    if (Vector3.Dot(mtx[0], Vector3.Cross(mtx[1], mtx[2])) < 0.00001f) {
      mtx[0] *= -1.0f;
      mtx[1] *= -1.0f;
      mtx[2] *= -1.0f;

      scaleX *= -1.0f;
      scaleY *= -1.0f;
      scaleZ *= -1.0f;
    }

    rotateY = -(float)Math.Asin(-mtx[0][2]);

    if (Math.Abs(Math.Cos(rotateY)) >= 0.00001f) {
      rotateX = (float)Math.Atan2(mtx[1][2], mtx[2][2]);
      rotateZ = (float)Math.Atan2(mtx[0][1], mtx[0][0]);
    }
    else {
      rotateX = (float)Math.Atan2(mtx[1][0], mtx[1][1]);
      rotateZ = 0.0f;
    }
  }

  public static void ToEulerZXY(Matrix3 m, out float x, out float y, out float z) {
    if (m[2][1] < 1.0f) {
      if (m[2][1] > -1.0f) {
        x = (float)Math.Asin(-m[2][1]);
        z = (float)Math.Atan2(m[0][1], m[1][1]);
        y = (float)Math.Atan2(-m[2][0], m[2][2]);
      }
      else {
        // The solution is not unique. Choosing z = 0.
        x = (float)Math.PI * 0.5f;
        z = 0.0f;
        y = (float)Math.Atan2(m[0][2], m[0][0]);
      }
    } else {
      // The solutions is not unique. Choosing z = 0.
      x = -(float)Math.PI * 0.5f;
      z = 0.0f;
      y = (float)Math.Atan2(m[0][2], m[0][0]);
    }
  }

}

}

