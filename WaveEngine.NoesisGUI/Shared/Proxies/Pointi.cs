//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Pointi {

  [MarshalAs(UnmanagedType.I4)]
  private int _x;
  [MarshalAs(UnmanagedType.I4)]
  private int _y;

  public int this[uint i] {
    get {
      switch (i) {
        case 0: return X;
        case 1: return Y;
        default: throw new IndexOutOfRangeException();
      }
    }
    set {
      switch (i) {
        case 0: X = value; break;
        case 1: Y = value; break;
        default: throw new IndexOutOfRangeException();
      }
    }
  }

  public int X {
    get { return this._x; }
    set { this._x = value; }
  }

  public int Y {
    get { return this._y; }
    set { this._y = value; }
  }

  public static Pointi Zero {
    get { return new Pointi(0, 0); }
  }

  public static Pointi XAxis {
    get { return new Pointi(1, 0); }
  }

  public static Pointi YAxis {
    get { return new Pointi(0, 1); }
  }

  public Pointi(int x, int y) {
    this._x = x;
    this._y = y;
  }

  public Pointi(Point point) : this((int)point.X, (int)point.Y) {
  }

  public Pointi(Sizei size) : this((int)size.Width, (int)size.Height) {
  }

  public static Pointi operator+(Pointi v) {
    return v;
  }

  public static Pointi operator-(Pointi v) {
    return new Pointi(-v.X, -v.Y);
  }

  public static Pointi operator+(Pointi v0, Pointi v1) {
    return new Pointi(v0.X + v1.X, v0.Y + v1.Y);
  }

  public static Pointi operator-(Pointi v0, Pointi v1) {
    return new Pointi(v0.X - v1.X, v0.Y - v1.Y);
  }

  public static Pointi operator*(Pointi v, int k) {
    return new Pointi(v.X * k, v.Y * k);
  }

  public static Pointi operator*(int k, Pointi v) {
    return v * k;
  }

  public static Pointi operator/(Pointi v, int k) {
    if (k == 0) { throw new DivideByZeroException(); }
    return new Pointi(v.X / k, v.Y / k);
  }

  public static bool operator==(Pointi v0, Pointi v1) {
    return v0.X == v1.X && v0.Y == v1.Y;
  }

  public static bool operator!=(Pointi v0, Pointi v1) {
    return !(v0 == v1);
  }

  public override bool Equals(Object obj) {
    return obj is Pointi && this == (Pointi)obj;
  }

  public bool Equals(Pointi v) {
    return this == v;
  }

  public override int GetHashCode() {
    return X ^ Y;
  }

  public override string ToString() {
    return String.Format("{0},{1}", X, Y);
  }

  public static float LengthSquared(Pointi v) {
    return v.X * v.X + v.Y * v.Y;
  }

  public static Pointi PerpendicularCCW(Pointi v) {
    return new Pointi(-v.Y, v.X);
  }

  public static Pointi PerpendicularCW(Pointi v) {
    return new Pointi(v.Y, -v.X);
  }

  public static Pointi Perpendicular(Pointi v, bool cw) {
    return cw ? PerpendicularCW(v) : PerpendicularCCW(v);
  }

  public static float Dot(Pointi v0, Pointi v1) {
    return v0.X * v1.X + v0.Y * v1.Y;
  }

  public static float PerpDot(Pointi v0, Pointi v1) {
    return v0.X * v1.Y - v0.Y * v1.X;
  }

  public static Pointi Parse(string str) {
    Pointi p;
    if (Pointi.TryParse(str, out p)) {
      return p;
    }
    throw new ArgumentException("Cannot create Pointi from '" + str + "'");
  }

  public static bool TryParse(string str, out Pointi result) {
    bool ret = NoesisGUI_PINVOKE.Pointi_TryParse(str != null ? str : string.Empty, out result);
    if (NoesisGUI_PINVOKE.SWIGPendingException.Pending) throw NoesisGUI_PINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}

