//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Color {

  [MarshalAs(UnmanagedType.R4)]
  private float _r;
  [MarshalAs(UnmanagedType.R4)]
  private float _g;
  [MarshalAs(UnmanagedType.R4)]
  private float _b;
  [MarshalAs(UnmanagedType.R4)]
  private float _a;

  public byte A {
    get { return Color.ToByte(_a); }
    set { _a = Color.FromByte(value); }
  }

  public byte R {
    get { return Color.ToByte(_r); }
    set { _r = Color.FromByte(value); }
  }

  public byte G {
    get { return Color.ToByte(_g); }
    set { _g = Color.FromByte(value); }
  }

  public byte B {
    get { return Color.ToByte(_b); }
    set { _b = Color.FromByte(value); }
  }

  public float ScA {
    get { return _a; }
    set { _a = value; }
  }

  public float ScR {
    get { return Color.sRgbToScRgb(_r); }
    set { _r = Color.ScRgbTosRgb(value); }
  }

  public float ScG {
    get { return Color.sRgbToScRgb(_g); }
    set { _g = Color.ScRgbTosRgb(value); }
  }

  public float ScB {
    get { return Color.sRgbToScRgb(_b); }
    set { _b = Color.ScRgbTosRgb(value); }
  }

  private static float FromByte(byte v) {
    return v / 255.0f;
  }

  private static byte ToByte(float v) {
    return (byte)Math.Round(Math.Max(0.0f, Math.Min(v * 255.0f, 255.0f)));
  }

  private static float sRgbToScRgb(float v) {
    if ((double)v <= 0.0) {
      return 0f;
    }
    if ((double)v <= 0.04045) {
      return v / 12.92f;
    }
    if (v < 1f) {
      return (float)Math.Pow(((double)v + 0.055) / 1.055, 2.4);
    }
    return 1f;
  }

  private static float ScRgbTosRgb(float v) {
    if ((double)v <= 0.0) {
      return 0f;
    }
    if ((double)v <= 0.0031308) {
      return (255f * v * 12.92f + 0.5f) / 255f;
    }
    if ((double)v < 1.0) {
      return (255f * (1.055f * (float)Math.Pow((double)v, 0.41666666666666669) - 0.055f) + 0.5f) / 255f;
    }
    return 1f;
  }

  public static Color FromRgb(byte r, byte g, byte b) {
    return new Color { A = 255, R = r, G = g, B = b };
  }

  public static Color FromArgb(byte a, byte r, byte g, byte b) {
    return new Color { A = a, R = r, G = g, B = b };
  }

  public static Color FromScRgb(float a, float r, float g, float b) {
    return new Color { ScA = a, ScR = r, ScG = g, ScB = b };
  }

  public void Clamp() {
    ScA = Color.Clamp(ScA);
    ScR = Color.Clamp(ScR);
    ScG = Color.Clamp(ScG);
    ScB = Color.Clamp(ScB);
  }

  private static float Clamp(float v) {
    return v < 0f ? 0f : (v > 1f ? 1f : v);
  }

  public static Color Add(Color l, Color r) {
    return Color.FromScRgb(l.ScA + r.ScA, l.ScR + r.ScR, l.ScG + r.ScG, l.ScB + r.ScB);
  }

  public static Color Subtract(Color l, Color r) {
    return Color.FromScRgb(l.ScA - r.ScA, l.ScR - r.ScR, l.ScG - r.ScG, l.ScB - r.ScB);
  }

  public static Color Multiply(Color c, float k) {
    return Color.FromScRgb(c.ScA * k, c.ScR * k, c.ScG * k, c.ScB * k);
  }

  public static bool Equals(Color color1, Color color2) {
    return color1 == color2;
  }

  public bool Equals(Color color) {
    return this == color;
  }

  public override bool Equals(Object obj) {
    return obj is Color && this == (Color)obj;
  }

  public override int GetHashCode() {
    return ((ScR.GetHashCode() ^ ScG.GetHashCode()) ^ ScB.GetHashCode()) ^ ScA.GetHashCode();
  }

  public override string ToString() {
    uint argb = ((uint)A << 24 | (uint)R << 16 | (uint)G << 8 | (uint)B);
    return String.Format("#{0:X8}", argb);
  }

  public static bool AreClose(Color l, Color r) {
    return Color.AreClose(l.ScA, r.ScA) && Color.AreClose(l.ScR, r.ScR) &&
      Color.AreClose(l.ScG, r.ScG) && Color.AreClose(l.ScB, r.ScB);
  }

  private static bool AreClose(float a, float b) {
    return Math.Abs(a - b) < 0.000001f;
  }

  public static Color operator +(Color l, Color r) {
    return Color.Add(l, r);
  }

  public static Color operator -(Color l, Color r) {
    return Color.Subtract(l, r);
  }

  public static Color operator *(Color color, float coefficient) {
    return Color.Multiply(color, coefficient);
  }

  public static bool operator ==(Color l, Color r) {
    return l.ScA == r.ScA && l.ScR == r.ScR && l.ScG == r.ScG && l.ScB == r.ScB;
  }

  public static bool operator !=(Color l, Color r) {
    return !(l == r);
  }

}

}

