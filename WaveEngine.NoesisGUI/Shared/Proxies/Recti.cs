//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Recti {

  [MarshalAs(UnmanagedType.I4)]
  private int _x;

  [MarshalAs(UnmanagedType.I4)]
  private int _y;

  [MarshalAs(UnmanagedType.U4)]
  private uint _w;

  [MarshalAs(UnmanagedType.U4)]
  private uint _h;

  public int X {
    get { return this._x; }
    set { this._x = value; }
  }

  public int Y {
    get { return this._y; }
    set { this._y = value; }
  }

  public uint Width {
    get { return this._w; }
    set { this._w = value; }
  }

  public uint Height {
    get { return this._h; }
    set { this._h = value; }
  }

  public Pointi Location {
    get { return new Pointi(X, Y); }
    set { X = value.X; Y = value.Y; }
  }

  public Sizei Size {
    get { return new Sizei(Width, Height); }
    set { Width = value.Width; Height = value.Height; }
  }

  public int Left {
    get { return X; }
  }

  public int Right {
    get { return X + (int)Width; }
  }
  
  public int Top {
    get { return Y; }
  }

  public int Bottom {
    get { return Y + (int)Height; }
  }

  public Pointi TopLeft {
    get { return new Pointi(Left, Top); }
  }

  public Pointi TopRight {
    get { return new Pointi(Right, Top); }
  }

  public Pointi BottomLeft {
    get { return new Pointi(Left, Bottom); }
  }

  public Pointi BottomRight {
    get { return new Pointi(Right, Bottom); }
  }

  public bool IsEmpty {
    get { return Width == 0.0f || Height == 0.0f; }
  }

  public static Recti Empty {
    get { return new Recti(); }
  }

  public static Recti Infinite {
    get {
      return new Recti(
        -Int32.MaxValue, -Int32.MaxValue,
        UInt32.MaxValue, UInt32.MaxValue);
    }
  }

  public Recti(int x, int y, uint width, uint height) {
    this._x = x;
    this._y = y;
    this._w = width;
    this._h = height;
  }

  public Recti(Sizei size) : this(0, 0, size.Width, size.Height)
  {
  }

  public Recti(Pointi p, Sizei size) : this(p.X, p.Y, size.Width, size.Height)
  {
  }

  public Recti(Rect rect) : this((int)rect.X, (int)rect.Y, (uint)rect.Width, (uint)rect.Height)
  {
  }

  public static bool operator==(Recti r0, Recti r1) {
    return r0.X == r1.X && r0.Y == r1.Y && r0.Width == r1.Width && r0.Height == r1.Height;
  }

  public static bool operator!=(Recti r0, Recti r1) {
    return !(r0 == r1);
  }

  public override bool Equals(Object obj) {
    return obj is Recti && this == (Recti)obj;
  }

  public bool Equals(Recti r) {
    return this == r;
  }

  public override int GetHashCode() {
    return ((X.GetHashCode() ^ Y.GetHashCode()) ^ Width.GetHashCode()) ^ Height.GetHashCode();
  }

  public override string ToString() {
    return String.Format("{0},{1},{2},{3}", X, Y, Width, Height);
  }

  public bool Contains(int x, int y) {
    return x >= Left && x <= Right && y >= Top && y <= Bottom;
  }

  public bool Contains(Pointi point) {
    return Contains(point.X, point.Y);
  }

  public bool Contains(Recti rect) {
    return rect.Left >= Left && rect.Right <= Right && rect.Top >= Top && rect.Bottom <= Bottom;
  }

  public void Inflate(int width, int height) {
    int w2 = width * 2;
    int h2 = height * 2;
    if ((w2 < 0.0f && -w2 >= Width) || (h2 < 0.0f && -h2 >= Height)) {
      this = Empty;
    }
    else {
      X -= width;
      Y -= height;
      Width = (uint)((int)Width + w2);
      Height = (uint)((int)Height + h2);
    }
  }

  public void Inflate(Sizei size) {
    Inflate((int)size.Width, (int)size.Height);
  }

  public Recti Intersect(Recti rect) {
    int x = rect.Left < Left ? (rect.Right > Left ? Left : 0) : (rect.Left < Right ? rect.Left : 0);
    int y = rect.Top < Top ? (rect.Bottom > Top ? Top : 0) : (rect.Top < Bottom ? rect.Top : 0);
    uint w = (uint)Math.Max(0.0f, (rect.Right > Right ? (rect.Left < Right ? Right : 0) : (rect.Right > Left ? rect.Right : 0)) - x);
    uint h = (uint)Math.Max(0.0f, (rect.Bottom > Bottom ? (rect.Top < Bottom ? Bottom : 0) : (rect.Bottom > Top ? rect.Bottom : 0)) - y);
    if (w == 0 || h == 0) {
      return Recti.Empty;
    }
    else {
      return new Recti(x, y, w, h);
    }
  }

  public bool IntersectsWith(Recti rect) {
    return !Intersect(rect).IsEmpty;
  }

  public void Offset(int x, int y) {
    X += x;
    Y += y;
  }

  public void Offset(Pointi offset) {
    Offset(offset.X, offset.Y);
  }

  public void Scale(int scaleX, int scaleY) {
    if (scaleX < 0) {
      Width *= (uint)-scaleX;
      X = X * scaleX - (int)Width;
    }
    else {
      Width *= (uint)scaleX;
      X *= scaleX;
    }
    if (scaleY < 0) {
      Height *= (uint)-scaleY;
      Y = Y * scaleY - (int)Height;
    }
    else {
      Height *= (uint)scaleY;
      Y *= scaleY;
    }
  }

  public void Expand(Pointi point) {
    float right = Right;
    float bottom = Bottom;
    X = Math.Min(X, point.X);
    Y = Math.Min(Y, point.Y);
    Width = (uint)(Math.Max(right, point.X) - X);
    Height = (uint)(Math.Max(bottom, point.Y) - Y);
  }

  public void Expand(Recti rect) {
    float right = Right;
    float bottom = Bottom;
    X = Math.Min(X, rect.X);
    Y = Math.Min(Y, rect.Y);
    Width = (uint)(Math.Max(right, rect.Right) - X);
    Height = (uint)(Math.Max(bottom, rect.Bottom) - Y);
  }

  public static Recti Parse(string str) {
    Recti r;
    if (Recti.TryParse(str, out r)) {
      return r;
    }
    throw new ArgumentException("Cannot create Recti from '" + str + "'");
  }

  public static bool TryParse(string str, out Recti result) {
    bool ret = NoesisGUI_PINVOKE.Recti_TryParse(str != null ? str : string.Empty, out result);
    if (NoesisGUI_PINVOKE.SWIGPendingException.Pending) throw NoesisGUI_PINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}

