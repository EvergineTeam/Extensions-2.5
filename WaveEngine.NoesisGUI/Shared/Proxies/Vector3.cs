//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Vector3 {

  [MarshalAs(UnmanagedType.R4)]
  private float _x;
  [MarshalAs(UnmanagedType.R4)]
  private float _y;
  [MarshalAs(UnmanagedType.R4)]
  private float _z;

  public float this[uint i] {
    get {
      switch (i) {
        case 0: return X;
        case 1: return Y;
        case 2: return Z;
        default: throw new IndexOutOfRangeException();
      }
    }
    set {
      switch (i) {
        case 0: X = value; break;
        case 1: Y = value; break;
        case 2: Z = value; break;
        default: throw new IndexOutOfRangeException();
      }
    }
  }

  public float X {
    get { return this._x; }
    set { this._x = value; }
  }

  public float Y {
    get { return this._y; }
    set { this._y = value; }
  }

  public float Z {
    get { return this._z; }
    set { this._z = value; }
  }

  public Point XY {
    get { return new Point(X, Y); }
  }

  public Point XZ {
    get { return new Point(X, Z); }
  }

  public Point YZ {
    get { return new Point(Y, Z); }
  }

  public static Vector3 Zero {
    get { return new Vector3(0.0f, 0.0f, 0.0f); }
  }

  public static Vector3 XAxis {
    get { return new Vector3(1.0f, 0.0f, 0.0f); }
  }

  public static Vector3 YAxis {
    get { return new Vector3(0.0f, 1.0f, 0.0f); }
  }

  public static Vector3 ZAxis {
    get { return new Vector3(0.0f, 0.0f, 1.0f); }
  }

  public Vector3(float x, float y, float z) {
    this._x = x;
    this._y = y;
    this._z = z;
  }

  public Vector3(Point v, float z) : this(v.X, v.Y, z) {
  }

  public static Vector3 operator+(Vector3 v) {
    return v;
  }

  public static Vector3 operator-(Vector3 v) {
    return new Vector3(-v.X, -v.Y, -v.Z);
  }

  public static Vector3 operator+(Vector3 v0, Vector3 v1) {
    return new Vector3(v0.X + v1.X, v0.Y + v1.Y, v0.Z + v1.Z);
  }

  public static Vector3 operator-(Vector3 v0, Vector3 v1) {
    return new Vector3(v0.X - v1.X, v0.Y - v1.Y, v0.Z - v1.Z);
  }

  public static Vector3 operator*(Vector3 v, float f) {
    return new Vector3(v.X * f, v.Y * f, v.Z * f);
  }

  public static Vector3 operator*(float f, Vector3 v) {
    return v * f;
  }

  public static Vector3 operator/(Vector3 v, float f) {
    if (f == 0.0f) { throw new DivideByZeroException(); }
    return new Vector3(v.X / f, v.Y / f, v.Z / f);
  }

  public static bool operator==(Vector3 v0, Vector3 v1) {
    return v0.X == v1.X && v0.Y == v1.Y && v0.Z == v1.Z;
  }

  public static bool operator!=(Vector3 v0, Vector3 v1) {
    return !(v0 == v1);
  }

  public override bool Equals(System.Object obj) {
    return obj is Vector3 && this == (Vector3)obj;
  }

  public bool Equals(Vector3 v) {
    return this == v;
  }

  public override int GetHashCode() {
    return (X.GetHashCode() ^ Y.GetHashCode()) ^ Z.GetHashCode();
  }

  public override string ToString() {
    return String.Format("{0},{1},{2}", X, Y, Z);
  }

  public static float LengthSquared(Vector3 v) {
    return v.X * v.X + v.Y * v.Y + v.Z * v.Z;
  }

  public static float Length(Vector3 v) {
    return (float)Math.Sqrt((double)LengthSquared(v));
  }

  public static Vector3 Normalize(Vector3 v) {
    return v / Length(v);
  }

  public static Point Project(Vector3 v) {
    return v.XY / v.Z;
  }

  public static float Dot(Vector3 v0, Vector3 v1) {
    return v0.X * v1.X + v0.Y * v1.Y + v0.Z * v1.Z;
  }

  public static Vector3 Cross(Vector3 v0, Vector3 v1) {
    return new Vector3(
      v0.Y * v1.Z - v0.Z * v1.Y,
      v0.Z * v1.X - v0.X * v1.Z,
      v0.X * v1.Y - v0.Y * v1.X);
  }

}

}

